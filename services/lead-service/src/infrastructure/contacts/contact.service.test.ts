import 'reflect-metadata';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Result } from '@zuclubit/domain';
import { ContactService } from './contact.service';
import { ContactType, ContactRole } from '../../domain/value-objects';

// Mock DatabasePool
const mockQuery = vi.fn();
const mockPool = {
  query: mockQuery,
};

describe('ContactService', () => {
  let contactService: ContactService;

  beforeEach(() => {
    vi.clearAllMocks();
    contactService = new ContactService(mockPool as any);
  });

  describe('createContact', () => {
    it('should create a contact successfully', async () => {
      // Mock lead existence check
      mockQuery.mockResolvedValueOnce(
        Result.ok({ rows: [{ '?column?': 1 }] })
      );

      // Mock unset other primary contacts (since isPrimary: true)
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      // Mock contact insert - use mockImplementationOnce to capture and return the inserted data
      mockQuery.mockImplementationOnce((_query: string, values: unknown[]) => {
        return Promise.resolve(
          Result.ok({
            rows: [
              {
                id: values[0], // Use the UUID generated by Contact.create
                lead_id: values[1],
                first_name: values[3],
                last_name: values[4],
                email: values[5],
                phone: values[6],
                mobile_phone: values[7],
                job_title: values[8],
                department: values[9],
                contact_type: values[10],
                contact_role: values[11],
                is_primary: values[12],
                preferences: values[13],
                linkedin_url: values[14],
                notes: values[15],
                created_at: values[16],
                updated_at: values[17],
              },
            ],
          })
        );
      });

      // Mock history log
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.createContact(
        'lead-123',
        'tenant-123',
        {
          firstName: 'John',
          lastName: 'Doe',
          email: 'john@example.com',
          phone: '+1234567890',
          jobTitle: 'CTO',
          department: 'Engineering',
          type: ContactType.PRIMARY,
          role: ContactRole.CTO,
          isPrimary: true,
        },
        'user-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue().firstName).toBe('John');
      expect(result.getValue().lastName).toBe('Doe');
      expect(result.getValue().email).toBe('john@example.com');
    });

    it('should fail if lead does not exist', async () => {
      // Mock lead existence check - no lead found
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.createContact(
        'lead-123',
        'tenant-123',
        {
          firstName: 'John',
          lastName: 'Doe',
          email: 'john@example.com',
        },
        'user-123'
      );

      expect(result.isFailure).toBe(true);
      expect(result.error).toBe('Lead not found');
    });

    it('should fail with invalid email', async () => {
      // Mock lead existence check
      mockQuery.mockResolvedValueOnce(
        Result.ok({ rows: [{ '?column?': 1 }] })
      );

      const result = await contactService.createContact(
        'lead-123',
        'tenant-123',
        {
          firstName: 'John',
          lastName: 'Doe',
          email: 'invalid-email',
        },
        'user-123'
      );

      expect(result.isFailure).toBe(true);
      expect(result.error).toContain('email');
    });

    it('should fail with empty first name', async () => {
      // Mock lead existence check
      mockQuery.mockResolvedValueOnce(
        Result.ok({ rows: [{ '?column?': 1 }] })
      );

      const result = await contactService.createContact(
        'lead-123',
        'tenant-123',
        {
          firstName: '',
          lastName: 'Doe',
          email: 'john@example.com',
        },
        'user-123'
      );

      expect(result.isFailure).toBe(true);
      expect(result.error).toContain('First name');
    });
  });

  describe('getContactById', () => {
    it('should return contact when found', async () => {
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: null,
              mobile_phone: null,
              job_title: 'CTO',
              department: null,
              contact_type: 'primary',
              contact_role: 'cto',
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      const result = await contactService.getContactById(
        '123',
        'lead-123',
        'tenant-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue()?.id).toBe('123');
      expect(result.getValue()?.fullName).toBe('John Doe');
    });

    it('should return null when contact not found', async () => {
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.getContactById(
        '123',
        'lead-123',
        'tenant-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue()).toBeNull();
    });
  });

  describe('getContactsByLead', () => {
    it('should return all contacts for a lead', async () => {
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: null,
              mobile_phone: null,
              job_title: 'CTO',
              department: null,
              contact_type: 'primary',
              contact_role: 'cto',
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
            {
              id: '456',
              lead_id: 'lead-123',
              first_name: 'Jane',
              last_name: 'Smith',
              email: 'jane@example.com',
              phone: null,
              mobile_phone: null,
              job_title: 'CFO',
              department: 'Finance',
              contact_type: 'secondary',
              contact_role: 'cfo',
              is_primary: false,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      const result = await contactService.getContactsByLead(
        'lead-123',
        'tenant-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue().length).toBe(2);
    });

    it('should filter contacts by type', async () => {
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: null,
              mobile_phone: null,
              job_title: 'CTO',
              department: null,
              contact_type: 'primary',
              contact_role: 'cto',
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      const result = await contactService.getContactsByLead(
        'lead-123',
        'tenant-123',
        { type: ContactType.PRIMARY }
      );

      expect(result.isSuccess).toBe(true);
      // Verify the query was called with the filter
      expect(mockQuery).toHaveBeenCalledWith(
        expect.stringContaining('contact_type'),
        expect.arrayContaining(['primary'])
      );
    });
  });

  describe('updateContact', () => {
    it('should update contact successfully', async () => {
      // Mock getContactById
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: null,
              mobile_phone: null,
              job_title: 'CTO',
              department: null,
              contact_type: 'primary',
              contact_role: 'cto',
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      // Mock update query
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: '+1234567890',
              mobile_phone: null,
              job_title: 'CEO',
              department: null,
              contact_type: 'primary',
              contact_role: 'ceo',
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      // Mock history log
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.updateContact(
        '123',
        'lead-123',
        'tenant-123',
        {
          phone: '+1234567890',
          jobTitle: 'CEO',
          role: ContactRole.CEO,
        },
        'user-123'
      );

      expect(result.isSuccess).toBe(true);
    });

    it('should fail when contact not found', async () => {
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.updateContact(
        '123',
        'lead-123',
        'tenant-123',
        { phone: '+1234567890' },
        'user-123'
      );

      expect(result.isFailure).toBe(true);
      expect(result.error).toBe('Contact not found');
    });
  });

  describe('deleteContact', () => {
    it('should delete contact successfully', async () => {
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [{ id: '123' }],
        })
      );

      // Mock history log
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.deleteContact(
        '123',
        'lead-123',
        'tenant-123',
        'user-123'
      );

      expect(result.isSuccess).toBe(true);
    });

    it('should fail when contact not found', async () => {
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.deleteContact(
        '123',
        'lead-123',
        'tenant-123',
        'user-123'
      );

      expect(result.isFailure).toBe(true);
      expect(result.error).toBe('Contact not found');
    });
  });

  describe('setPrimaryContact', () => {
    it('should set contact as primary and unset others', async () => {
      // Mock unset other primary contacts
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      // Mock set primary
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            {
              id: '123',
              lead_id: 'lead-123',
              first_name: 'John',
              last_name: 'Doe',
              email: 'john@example.com',
              phone: null,
              mobile_phone: null,
              job_title: null,
              department: null,
              contact_type: 'primary',
              contact_role: null,
              is_primary: true,
              preferences: null,
              linkedin_url: null,
              notes: null,
              created_at: new Date(),
              updated_at: new Date(),
            },
          ],
        })
      );

      // Mock history log
      mockQuery.mockResolvedValueOnce(Result.ok({ rows: [] }));

      const result = await contactService.setPrimaryContact(
        '123',
        'lead-123',
        'tenant-123',
        'user-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue().isPrimary).toBe(true);
    });
  });

  describe('countContactsByType', () => {
    it('should return counts by type', async () => {
      mockQuery.mockResolvedValueOnce(
        Result.ok({
          rows: [
            { contact_type: 'primary', count: '2' },
            { contact_type: 'secondary', count: '3' },
          ],
        })
      );

      const result = await contactService.countContactsByType(
        'lead-123',
        'tenant-123'
      );

      expect(result.isSuccess).toBe(true);
      expect(result.getValue().primary).toBe(2);
      expect(result.getValue().secondary).toBe(3);
    });
  });
});
